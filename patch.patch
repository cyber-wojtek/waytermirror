--- a/waytermirror_client.cpp
+++ b/waytermirror_client.cpp
@@ -661,34 +661,43 @@
 // Input event handlers
 static void send_key_event(uint32_t keycode, bool pressed) {
-  if (input_socket < 0) return;
-  
+  // Track modifiers locally regardless of input forwarding
   bool is_shift = (keycode == KEY_LEFTSHIFT || keycode == KEY_RIGHTSHIFT);
   bool is_ctrl = (keycode == KEY_LEFTCTRL || keycode == KEY_RIGHTCTRL);
   bool is_alt = (keycode == KEY_LEFTALT || keycode == KEY_RIGHTALT);
   bool is_delete = (keycode == KEY_DELETE);
   bool is_x = (keycode == KEY_X);
   bool is_z = (keycode == KEY_Z);
   
   if (is_shift) shift_pressed = pressed;
   if (is_ctrl) ctrl_pressed = pressed;
   if (is_alt) alt_pressed = pressed;
   if (is_delete) delete_pressed = pressed;
   if (is_x) x_pressed = pressed;
   
-  // ZOOM: Check for zoom toggle (Ctrl+Alt+Shift+Delete+Z)
+  // ZOOM: Check for zoom toggle (Ctrl+Alt+Shift+Delete+Z) - works regardless of input forwarding
   if (pressed && is_z && shift_pressed.load() && ctrl_pressed.load() && alt_pressed.load() && delete_pressed.load()) {
     zoom_state.enabled = !zoom_state.enabled.load();
     std::cerr << "[ZOOM] Toggled: " << (zoom_state.enabled.load() ? "ON" : "OFF") << "\n";
     send_zoom_config();
-    return;
+    return;  // Don't forward zoom toggle to server
   }
   
-  // Check for exit combo
+  // Check for exit combo - works regardless of input forwarding
   if (pressed && shift_pressed.load() && ctrl_pressed.load() && alt_pressed.load() && 
       delete_pressed.load() && x_pressed.load()) {
     std::cerr << "\n[EXIT] Exit combo detected!\n";
     running = false;
-    return;
+    return;  // Don't forward exit combo to server
   }
   
+  // Only forward to server if input is enabled
+  if (!feature_input || input_socket < 0) {
+    return;
+  }
+  
   // Send normal key event
   MessageType type = MessageType::KEY_EVENT;
   KeyEvent evt{
@@ -704,9 +713,9 @@
 }
 
 static void send_mouse_move(int x, int y) {
-  if (input_socket < 0) return;
-  
-  // Update zoom center if zoom is enabled and following mouse
+  // Update zoom center if zoom is enabled and following mouse - works regardless of input forwarding
   if (zoom_state.enabled.load() && zoom_state.follow_mouse.load()) {
     zoom_state.center_x = x;
     zoom_state.center_y = y;
@@ -720,6 +729,11 @@
     }
   }
   
+  // Only forward to server if input is enabled
+  if (!feature_input || input_socket < 0) {
+    return;
+  }
+  
   MessageType type = MessageType::MOUSE_MOVE;
   MouseMove evt{x, y, (uint32_t)screen_width.load(), (uint32_t)screen_height.load()};
   
@@ -728,6 +742,11 @@
 }
 
 static void send_mouse_button(uint32_t button, bool pressed) {
+  // Only forward to server if input is enabled
+  if (!feature_input || input_socket < 0) {
+    return;
+  }
+  
   if (input_socket < 0) return;
   
   MessageType type = MessageType::MOUSE_BUTTON;
@@ -738,6 +757,11 @@
 }
 
 static void send_mouse_scroll(double dx, double dy) {
+  // Only forward to server if input is enabled
+  if (!feature_input || input_socket < 0) {
+    return;
+  }
+  
   if (input_socket < 0) return;
   
   // Send vertical scroll
@@ -838,7 +862,7 @@
 
 // Input thread with hotplug monitoring
 static void input_thread() {
+  // Always run input thread for local controls (zoom, exit combo) even if not forwarding to server
   struct pollfd fds[2];
   fds[0].fd = libinput_get_fd(li);
   fds[0].events = POLLIN;
@@ -850,7 +874,10 @@
   fds[1].fd = udev_monitor_get_fd(mon);
   fds[1].events = POLLIN;
   
-  std::cerr << "[INPUT] Thread started with libinput and hotplug monitoring\n";
+  std::cerr << "[INPUT] Thread started with libinput and hotplug monitoring";
+  if (!feature_input) {
+    std::cerr << " (local controls only - no forwarding to server)";
+  }
+  std::cerr << "\n";
   
   while (running) {
     int ret = poll(fds, 2, 1);  // CHANGED: 1ms instead of 100ms!
@@ -933,7 +960,7 @@
   std::cerr << "=======================\n\n";
 
   // Initialize libinput only if input is enabled
-  if (feature_input) {
+  // Initialize libinput for local controls (zoom, exit) even if not forwarding input
+  {
     // Check if running with sufficient privileges for libinput
     if (geteuid() != 0) {
       std::cerr << "\n=== WARNING ===\n";
@@ -949,45 +976,38 @@
     udev = udev_new();
     if (!udev) {
       std::cerr << "Failed to initialize udev\n";
-      if (feature_audio || feature_video || feature_microphone) {
-        std::cerr << "Continuing without input support\n";
-        feature_input = false;
-      } else {
-        return 1;
-      }
+      std::cerr << "Continuing without input support (including zoom controls)\n";
+      feature_input = false;
+      feature_zoom = false;
     } else {
       li = libinput_udev_create_context(&interface, nullptr, udev);
       if (!li) {
         std::cerr << "Failed to initialize libinput\n";
         udev_unref(udev);
-        if (feature_audio || feature_video || feature_microphone) {
-          std::cerr << "Continuing without input support\n";
-          feature_input = false;
-        } else {
-          return 1;
-        }
+        std::cerr << "Continuing without input support (including zoom controls)\n";
+        feature_input = false;
+        feature_zoom = false;
       } else {
         if (libinput_udev_assign_seat(li, "seat0") != 0) {
           std::cerr << "Failed to assign seat to libinput\n";
           libinput_unref(li);
           udev_unref(udev);
-          if (feature_audio || feature_video || feature_microphone) {
-            std::cerr << "Continuing without input support\n";
-            feature_input = false;
-          } else {
-            return 1;
-          }
+          std::cerr << "Continuing without input support (including zoom controls)\n";
+          feature_input = false;
+          feature_zoom = false;
         } else {
           std::cerr << "[INPUT] libinput initialized successfully\n";
           std::cerr << "[INPUT] Hotplug support enabled\n";
+          if (!feature_input) {
+            std::cerr << "[INPUT] Running in local-only mode (zoom/exit controls, no forwarding)\n";
+          }
           
           // Enumerate initial devices
           std::cerr << "[INPUT] Initial devices:\n";
           libinput_dispatch(li);
           process_libinput_events();
         }
       }
     }
   }
   
@@ -1172,9 +1192,14 @@
     std::cerr << "Compression: " << (config.compress ? "ON" : "OFF") << "\n";
   }
-  if (feature_input) {
-    std::cerr << "Using libinput with hotplug support\n";
+  if (li) {
+    std::cerr << "Using libinput with hotplug support";
+    if (!feature_input) {
+      std::cerr << " (local controls only)";
+    }
+    std::cerr << "\n";
     std::cerr << "Exit combo: Ctrl+Alt+Shift+Delete+X\n";
+    if (feature_zoom) {
+      std::cerr << "Zoom toggle: Ctrl+Alt+Shift+Delete+Z\n";
+    }
   }
   if (feature_audio) {
     std::cerr << "Audio playback enabled (system audio from server)\n";
@@ -1185,8 +1210,8 @@
   std::cerr << "=============================\n\n";
   
   // Start threads based on enabled features
   std::thread input_thr;
-  if (feature_input) {
+  if (li) {  // Start input thread if libinput initialized (for local controls even without forwarding)
     input_thr = std::thread(input_thread);
   }
   
@@ -1261,7 +1286,7 @@
     microphone_thr.join();
   }
   
-  if (feature_input && input_thr.joinable()) {
+  if (input_thr.joinable()) {
     input_thr.join();
   }
   
@@ -1278,7 +1303,7 @@
   if (microphone_socket >= 0) close(microphone_socket);
   
   // Cleanup resources
-  if (feature_input && li) {
+  if (li) {
     libinput_unref(li);
     udev_unref(udev);
   }